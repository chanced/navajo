#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
extern crate alloc;
mod keyring {
    use serde::Deserialize;
    use serde::Serialize;
    pub(crate) const KEY_ID_LEN: usize = 4;
    #[serde(try_from = "i8", into = "i8")]
    #[repr(i8)]
    pub enum KeyStatus {
        /// Indicates that the key is active and the primary key in the keyring. It
        /// will be used, by default, for encryption.
        ///
        /// The key will be used for decryption when aplicable (i.e. ciphertext
        /// encrypted with it).
        Primary = 0,
        /// The indicates that the key is active and can be used for encryption if
        /// specified.
        ///
        /// The key will be used for decryption when applicable (i.e. ciphertext
        /// encrypted with it).
        Secondary = 1,
        /// Indicates that the key is disabled and cannot be used for encryption
        /// except for [daead] queries. It can still be used to decrypt applicable
        /// ciphertext.
        Disabled = -1,
        /// Temporary keys are either generated by an agreement primitive, provided
        /// by a remote entity, or generated by a key derivation function.
        Temporary = -2,
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for KeyStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                KeyStatus::Primary => ::core::fmt::Formatter::write_str(f, "Primary"),
                KeyStatus::Secondary => ::core::fmt::Formatter::write_str(f, "Secondary"),
                KeyStatus::Disabled => ::core::fmt::Formatter::write_str(f, "Disabled"),
                KeyStatus::Temporary => ::core::fmt::Formatter::write_str(f, "Temporary"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KeyStatus {
        #[inline]
        fn clone(&self) -> KeyStatus {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for KeyStatus {}
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for KeyStatus {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for KeyStatus {
        #[inline]
        fn eq(&self, other: &KeyStatus) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for KeyStatus {}
    #[automatically_derived]
    impl ::core::cmp::Eq for KeyStatus {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[automatically_derived]
    impl ::core::hash::Hash for KeyStatus {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            ::core::hash::Hash::hash(&__self_tag, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyStatus {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serialize::serialize(
                    &_serde::__private::Into::<
                        i8,
                    >::into(_serde::__private::Clone::clone(self)),
                    __serializer,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyStatus {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::and_then(
                    <i8 as _serde::Deserialize>::deserialize(__deserializer),
                    |v| {
                        _serde::__private::TryFrom::try_from(v)
                            .map_err(_serde::de::Error::custom)
                    },
                )
            }
        }
    };
    impl Default for KeyStatus {
        fn default() -> Self {
            Self::Secondary
        }
    }
    impl KeyStatus {
        /// Returns `true` if `Primary`.
        pub fn is_primary(&self) -> bool {
            *self == Self::Primary
        }
        pub fn is_secondary(&self) -> bool {
            *self == Self::Secondary
        }
        pub fn is_temporary(&self) -> bool {
            *self == Self::Temporary
        }
        /// Returns `true` if `Disabled`.
        pub fn is_disabled(&self) -> bool {
            match self {
                Self::Disabled => true,
                _ => false,
            }
        }
    }
    impl TryFrom<i8> for KeyStatus {
        type Error = String;
        fn try_from(i: i8) -> Result<Self, Self::Error> {
            match i {
                0 => Ok(Self::Primary),
                1 => Ok(Self::Secondary),
                -1 => Ok(Self::Disabled),
                _ => {
                    Err({
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &["invalid key status: "],
                                &[::core::fmt::ArgumentV1::new_display(&i)],
                            ),
                        );
                        res
                    })
                }
            }
        }
    }
    impl From<KeyStatus> for i8 {
        fn from(s: KeyStatus) -> Self {
            s as i8
        }
    }
    /// Metadata for a particular key.
    pub struct KeyInfo<A> {
        pub id: u32,
        pub algorithm: A,
        pub status: KeyStatus,
        pub created_at_timestamp: u64,
        /// The public key, if applicable.
        pub pub_key: Option<Vec<u8>>,
    }
    #[automatically_derived]
    impl<A: ::core::fmt::Debug> ::core::fmt::Debug for KeyInfo<A> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_struct_field5_finish(
                f,
                "KeyInfo",
                "id",
                &&self.id,
                "algorithm",
                &&self.algorithm,
                "status",
                &&self.status,
                "created_at_timestamp",
                &&self.created_at_timestamp,
                "pub_key",
                &&self.pub_key,
            )
        }
    }
    #[automatically_derived]
    impl<A: ::core::clone::Clone> ::core::clone::Clone for KeyInfo<A> {
        #[inline]
        fn clone(&self) -> KeyInfo<A> {
            KeyInfo {
                id: ::core::clone::Clone::clone(&self.id),
                algorithm: ::core::clone::Clone::clone(&self.algorithm),
                status: ::core::clone::Clone::clone(&self.status),
                created_at_timestamp: ::core::clone::Clone::clone(
                    &self.created_at_timestamp,
                ),
                pub_key: ::core::clone::Clone::clone(&self.pub_key),
            }
        }
    }
    #[automatically_derived]
    impl<A> ::core::marker::StructuralPartialEq for KeyInfo<A> {}
    #[automatically_derived]
    impl<A: ::core::cmp::PartialEq> ::core::cmp::PartialEq for KeyInfo<A> {
        #[inline]
        fn eq(&self, other: &KeyInfo<A>) -> bool {
            self.id == other.id && self.algorithm == other.algorithm
                && self.status == other.status
                && self.created_at_timestamp == other.created_at_timestamp
                && self.pub_key == other.pub_key
        }
    }
    #[automatically_derived]
    impl<A> ::core::marker::StructuralEq for KeyInfo<A> {}
    #[automatically_derived]
    impl<A: ::core::cmp::Eq> ::core::cmp::Eq for KeyInfo<A> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            let _: ::core::cmp::AssertParamIsEq<u32>;
            let _: ::core::cmp::AssertParamIsEq<A>;
            let _: ::core::cmp::AssertParamIsEq<KeyStatus>;
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<Option<Vec<u8>>>;
        }
    }
    #[automatically_derived]
    impl<A: ::core::hash::Hash> ::core::hash::Hash for KeyInfo<A> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            ::core::hash::Hash::hash(&self.id, state);
            ::core::hash::Hash::hash(&self.algorithm, state);
            ::core::hash::Hash::hash(&self.status, state);
            ::core::hash::Hash::hash(&self.created_at_timestamp, state);
            ::core::hash::Hash::hash(&self.pub_key, state)
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<A> _serde::Serialize for KeyInfo<A>
        where
            A: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "KeyInfo",
                    false as usize + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "algorithm",
                    &self.algorithm,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "status",
                    &self.status,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "created_at_timestamp",
                    &self.created_at_timestamp,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "pub_key",
                    &self.pub_key,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, A> _serde::Deserialize<'de> for KeyInfo<A>
        where
            A: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "field identifier",
                        )
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "algorithm" => _serde::__private::Ok(__Field::__field1),
                            "status" => _serde::__private::Ok(__Field::__field2),
                            "created_at_timestamp" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            "pub_key" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"algorithm" => _serde::__private::Ok(__Field::__field1),
                            b"status" => _serde::__private::Ok(__Field::__field2),
                            b"created_at_timestamp" => {
                                _serde::__private::Ok(__Field::__field3)
                            }
                            b"pub_key" => _serde::__private::Ok(__Field::__field4),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(
                            __deserializer,
                            __FieldVisitor,
                        )
                    }
                }
                struct __Visitor<'de, A>
                where
                    A: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<KeyInfo<A>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, A> _serde::de::Visitor<'de> for __Visitor<'de, A>
                where
                    A: _serde::Deserialize<'de>,
                {
                    type Value = KeyInfo<A>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct KeyInfo",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            u32,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct KeyInfo with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            A,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct KeyInfo with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            KeyStatus,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct KeyInfo with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field3 = match match _serde::de::SeqAccess::next_element::<
                            u64,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct KeyInfo with 5 elements",
                                    ),
                                );
                            }
                        };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Option<Vec<u8>>,
                        >(&mut __seq) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(
                                    _serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct KeyInfo with 5 elements",
                                    ),
                                );
                            }
                        };
                        _serde::__private::Ok(KeyInfo {
                            id: __field0,
                            algorithm: __field1,
                            status: __field2,
                            created_at_timestamp: __field3,
                            pub_key: __field4,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<A> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<KeyStatus> = _serde::__private::None;
                        let mut __field3: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field4: _serde::__private::Option<Option<Vec<u8>>> = _serde::__private::None;
                        while let _serde::__private::Some(__key)
                            = match _serde::de::MapAccess::next_key::<
                                __Field,
                            >(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("id"),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "algorithm",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<A>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field("status"),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            KeyStatus,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::__private::Option::is_some(&__field3) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "created_at_timestamp",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::__private::Option::is_some(&__field4) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "pub_key",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Option<Vec<u8>>,
                                        >(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("algorithm") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("status") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::__private::Some(__field3) => __field3,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field(
                                    "created_at_timestamp",
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::__private::Some(__field4) => __field4,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("pub_key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(KeyInfo {
                            id: __field0,
                            algorithm: __field1,
                            status: __field2,
                            created_at_timestamp: __field3,
                            pub_key: __field4,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "id",
                    "algorithm",
                    "status",
                    "created_at_timestamp",
                    "pub_key",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KeyInfo",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyInfo<A>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
pub use keyring::*;
pub mod aead {}
pub mod error {
    use core::fmt;
    use std::borrow::Cow;
    pub use random::Error as RandError;
    #[cfg(feature = "ring")]
    use ring_compat::ring;
    pub struct KeyNotFoundError(pub u32);
    #[automatically_derived]
    impl ::core::fmt::Debug for KeyNotFoundError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "KeyNotFoundError",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for KeyNotFoundError {
        #[inline]
        fn clone(&self) -> KeyNotFoundError {
            let _: ::core::clone::AssertParamIsClone<u32>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for KeyNotFoundError {}
    impl fmt::Display for KeyNotFoundError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &["missing key: "],
                    &[::core::fmt::ArgumentV1::new_display(&self.0)],
                ),
            )
        }
    }
    impl std::error::Error for KeyNotFoundError {}
    pub struct UnspecifiedError;
    #[automatically_derived]
    impl ::core::clone::Clone for UnspecifiedError {
        #[inline]
        fn clone(&self) -> UnspecifiedError {
            UnspecifiedError
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for UnspecifiedError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::write_str(f, "UnspecifiedError")
        }
    }
    #[cfg(feature = "ring")]
    impl From<ring_compat::ring::error::Unspecified> for UnspecifiedError {
        fn from(_: ring_compat::ring::error::Unspecified) -> Self {
            Self
        }
    }
    impl fmt::Display for UnspecifiedError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(&["unspecified error"], &[]))
        }
    }
    impl std::error::Error for UnspecifiedError {}
    pub enum EncryptError {
        Unspecified,
        MissingPrimaryKey,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for EncryptError {
        #[inline]
        fn clone(&self) -> EncryptError {
            match self {
                EncryptError::Unspecified => EncryptError::Unspecified,
                EncryptError::MissingPrimaryKey => EncryptError::MissingPrimaryKey,
            }
        }
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for EncryptError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EncryptError::Unspecified => {
                    ::core::fmt::Formatter::write_str(f, "Unspecified")
                }
                EncryptError::MissingPrimaryKey => {
                    ::core::fmt::Formatter::write_str(f, "MissingPrimaryKey")
                }
            }
        }
    }
    impl fmt::Display for EncryptError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Unspecified => fmt::Display::fmt(&UnspecifiedError, f),
                Self::MissingPrimaryKey => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(&["missing primary key"], &[]),
                        )
                }
            }
        }
    }
    impl std::error::Error for EncryptError {}
    impl From<UnspecifiedError> for EncryptError {
        fn from(_: UnspecifiedError) -> Self {
            Self::Unspecified
        }
    }
    pub(crate) enum NonceSequenceError {
        CounterLimitExceeded,
        UnspecifiedError,
    }
    impl From<ring::error::Unspecified> for NonceSequenceError {
        fn from(_: ring::error::Unspecified) -> Self {
            Self::UnspecifiedError
        }
    }
    pub enum DecryptStreamError<E> {
        Unspecified,
        KeyNotFound(KeyNotFoundError),
        Malformed(MalformedError),
        Upstream(E),
    }
    #[automatically_derived]
    impl<E: ::core::fmt::Debug> ::core::fmt::Debug for DecryptStreamError<E> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DecryptStreamError::Unspecified => {
                    ::core::fmt::Formatter::write_str(f, "Unspecified")
                }
                DecryptStreamError::KeyNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "KeyNotFound",
                        &__self_0,
                    )
                }
                DecryptStreamError::Malformed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Malformed",
                        &__self_0,
                    )
                }
                DecryptStreamError::Upstream(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Upstream",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl<E> fmt::Display for DecryptStreamError<E>
    where
        E: std::error::Error,
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                DecryptStreamError::Unspecified => {
                    fmt::Display::fmt(&UnspecifiedError, f)
                }
                DecryptStreamError::KeyNotFound(k) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["unknown key: "],
                                &[::core::fmt::ArgumentV1::new_display(&k)],
                            ),
                        )
                }
                DecryptStreamError::Malformed(e) => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["malformed ciphertext: "],
                                &[::core::fmt::ArgumentV1::new_display(&e)],
                            ),
                        )
                }
                DecryptStreamError::Upstream(e) => fmt::Display::fmt(e, f),
            }
        }
    }
    impl<E> std::error::Error for DecryptStreamError<E>
    where
        E: std::error::Error,
    {}
    impl<E> From<DecryptError> for DecryptStreamError<E>
    where
        E: std::error::Error,
    {
        fn from(e: DecryptError) -> Self {
            match e {
                DecryptError::Unspecified => Self::Unspecified,
                DecryptError::KeyNotFound(k) => Self::KeyNotFound(k),
                DecryptError::Malformed(e) => Self::Malformed(e),
            }
        }
    }
    pub enum EncryptStreamError<E> {
        Unspecified,
        MissingPrimaryKey,
        CounterLimitExceeded,
        EmptyCleartext,
        Upstream(E),
    }
    #[automatically_derived]
    impl<E: ::core::fmt::Debug> ::core::fmt::Debug for EncryptStreamError<E> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                EncryptStreamError::Unspecified => {
                    ::core::fmt::Formatter::write_str(f, "Unspecified")
                }
                EncryptStreamError::MissingPrimaryKey => {
                    ::core::fmt::Formatter::write_str(f, "MissingPrimaryKey")
                }
                EncryptStreamError::CounterLimitExceeded => {
                    ::core::fmt::Formatter::write_str(f, "CounterLimitExceeded")
                }
                EncryptStreamError::EmptyCleartext => {
                    ::core::fmt::Formatter::write_str(f, "EmptyCleartext")
                }
                EncryptStreamError::Upstream(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Upstream",
                        &__self_0,
                    )
                }
            }
        }
    }
    impl<E> From<UnspecifiedError> for DecryptStreamError<E> {
        fn from(_: UnspecifiedError) -> Self {
            Self::Unspecified
        }
    }
    impl<E> From<NonceSequenceError> for EncryptStreamError<E> {
        fn from(e: NonceSequenceError) -> Self {
            match e {
                NonceSequenceError::CounterLimitExceeded => Self::CounterLimitExceeded,
                NonceSequenceError::UnspecifiedError => Self::Unspecified,
            }
        }
    }
    impl<E> fmt::Display for EncryptStreamError<E>
    where
        E: std::error::Error,
    {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Unspecified => fmt::Display::fmt(&UnspecifiedError, f),
                Self::MissingPrimaryKey => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(&["missing primary key"], &[]),
                        )
                }
                Self::Upstream(e) => fmt::Display::fmt(e, f),
                Self::CounterLimitExceeded => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(
                                &["counter limit exceeded"],
                                &[],
                            ),
                        )
                }
                Self::EmptyCleartext => {
                    f
                        .write_fmt(
                            ::core::fmt::Arguments::new_v1(&["cleartext is empty"], &[]),
                        )
                }
            }
        }
    }
    impl<E> std::error::Error for EncryptStreamError<E>
    where
        E: std::error::Error,
    {}
    impl<E> From<UnspecifiedError> for EncryptStreamError<E> {
        fn from(e: UnspecifiedError) -> Self {
            Self::Unspecified
        }
    }
    pub enum DecryptError {
        /// The underlying cryptography library, *ring* returned an unspecified error.
        Unspecified,
        /// The keyset does not contain the key used to encrypt the ciphertext
        KeyNotFound(KeyNotFoundError),
        /// The ciphertext is malformed. See the opaque error message for details.
        Malformed(MalformedError),
    }
    #[automatically_derived]
    impl ::core::fmt::Debug for DecryptError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                DecryptError::Unspecified => {
                    ::core::fmt::Formatter::write_str(f, "Unspecified")
                }
                DecryptError::KeyNotFound(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "KeyNotFound",
                        &__self_0,
                    )
                }
                DecryptError::Malformed(__self_0) => {
                    ::core::fmt::Formatter::debug_tuple_field1_finish(
                        f,
                        "Malformed",
                        &__self_0,
                    )
                }
            }
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for DecryptError {
        #[inline]
        fn clone(&self) -> DecryptError {
            match self {
                DecryptError::Unspecified => DecryptError::Unspecified,
                DecryptError::KeyNotFound(__self_0) => {
                    DecryptError::KeyNotFound(::core::clone::Clone::clone(__self_0))
                }
                DecryptError::Malformed(__self_0) => {
                    DecryptError::Malformed(::core::clone::Clone::clone(__self_0))
                }
            }
        }
    }
    impl From<KeyNotFoundError> for DecryptError {
        fn from(e: KeyNotFoundError) -> Self {
            Self::KeyNotFound(e)
        }
    }
    impl fmt::Display for DecryptError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::Unspecified => fmt::Display::fmt(&UnspecifiedError, f),
                Self::Malformed(e) => fmt::Display::fmt(e, f),
                Self::KeyNotFound(e) => fmt::Display::fmt(e, f),
            }
        }
    }
    impl std::error::Error for DecryptError {}
    impl From<UnspecifiedError> for DecryptError {
        fn from(e: UnspecifiedError) -> Self {
            Self::Unspecified
        }
    }
    impl From<ring::error::Unspecified> for DecryptError {
        fn from(_: ring::error::Unspecified) -> Self {
            Self::Unspecified
        }
    }
    pub struct MalformedError(Cow<'static, str>);
    #[automatically_derived]
    impl ::core::fmt::Debug for MalformedError {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "MalformedError",
                &&self.0,
            )
        }
    }
    #[automatically_derived]
    impl ::core::clone::Clone for MalformedError {
        #[inline]
        fn clone(&self) -> MalformedError {
            MalformedError(::core::clone::Clone::clone(&self.0))
        }
    }
    impl<E> From<MalformedError> for DecryptStreamError<E> {
        fn from(e: MalformedError) -> Self {
            Self::Malformed(e)
        }
    }
    impl From<MalformedError> for DecryptError {
        fn from(e: MalformedError) -> Self {
            Self::Malformed(e)
        }
    }
    impl From<&'static str> for MalformedError {
        fn from(s: &'static str) -> Self {
            Self(Cow::Borrowed(s))
        }
    }
    impl From<String> for MalformedError {
        fn from(s: String) -> Self {
            Self(Cow::Owned(s))
        }
    }
    impl fmt::Display for MalformedError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &["malformed ciphertext: "],
                    &[::core::fmt::ArgumentV1::new_display(&&self.0)],
                ),
            )
        }
    }
    impl std::error::Error for MalformedError {}
    pub(crate) enum HeaderError {
        Unspecified,
        Malformed(MalformedError),
        KeyNotFound(KeyNotFoundError),
    }
    pub struct InvalidAlgorithm(pub(crate) u8);
    #[automatically_derived]
    impl ::core::clone::Clone for InvalidAlgorithm {
        #[inline]
        fn clone(&self) -> InvalidAlgorithm {
            let _: ::core::clone::AssertParamIsClone<u8>;
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for InvalidAlgorithm {}
    #[automatically_derived]
    impl ::core::fmt::Debug for InvalidAlgorithm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            ::core::fmt::Formatter::debug_tuple_field1_finish(
                f,
                "InvalidAlgorithm",
                &&self.0,
            )
        }
    }
    impl fmt::Display for InvalidAlgorithm {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(
                ::core::fmt::Arguments::new_v1(
                    &["invalid algorithm: "],
                    &[::core::fmt::ArgumentV1::new_display(&self.0)],
                ),
            )
        }
    }
    impl std::error::Error for InvalidAlgorithm {}
    impl From<u8> for InvalidAlgorithm {
        fn from(v: u8) -> Self {
            Self(v)
        }
    }
    pub enum MacError {}
}
mod id {
    use std::collections::HashSet;
    use crate::error::UnspecifiedError;
    use crate::rand;
    pub(crate) fn gen_id() -> u32 {
        let mut data = [0; 4];
        rand::fill(&mut data);
        let mut value: u32 = u32::from_be_bytes(data);
        while value < 100_000_000 {
            rand::fill(&mut data);
            value = u32::from_be_bytes(data);
        }
        value
    }
    pub(crate) fn gen_unique_id(lookup: &HashSet<u32>) -> u32 {
        let mut id = gen_id();
        while lookup.contains(&id) {
            id = gen_id();
        }
        id
    }
}
pub(crate) use id::*;
mod rand {
    #[cfg(feature = "ring")]
    use ring_compat::ring::rand::{SecureRandom as _, SystemRandom};
    use random::{rngs::OsRng, CryptoRng, RngCore};
    pub(crate) fn fill(dst: &mut [u8]) {
        SecureRandom::new().fill_bytes(dst)
    }
    #[cfg(feature = "ring")]
    pub struct SecureRandom;
    impl CryptoRng for SecureRandom {}
    impl SecureRandom {
        pub fn new() -> Self {
            Self
        }
    }
    #[cfg(feature = "ring")]
    impl RngCore for SecureRandom {
        fn next_u32(&mut self) -> u32 {
            let mut data = [0; 4];
            SystemRandom::new()
                .fill(&mut data)
                .ok()
                .map_or(OsRng.next_u32(), |_| u32::from_be_bytes(data))
        }
        fn next_u64(&mut self) -> u64 {
            let mut data = [0; 8];
            SystemRandom::new()
                .fill(&mut data)
                .ok()
                .map_or(OsRng.next_u64(), |_| u64::from_be_bytes(data))
        }
        fn fill_bytes(&mut self, dest: &mut [u8]) {
            SystemRandom::new().fill(dest).ok().map_or(OsRng.fill_bytes(dest), |_| ())
        }
        fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), random::Error> {
            SystemRandom::new().fill(dest).or_else(|_| OsRng.try_fill_bytes(dest))
        }
    }
}
pub use rand::SecureRandom;
mod timestamp {
    use std::time::{SystemTime, UNIX_EPOCH};
    pub(crate) fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
pub mod hkdf {
    pub enum Algorithm {
        HkdfSha256,
        HkdfSha384,
        HkdfSha512,
    }
}
pub mod mac {
    mod algorithm {
        use serde_repr::{Deserialize_repr, Serialize_repr};
        #[repr(u8)]
        pub enum Algorithm {
            Sha256 = 0,
            Sha512 = 1,
            Sha224 = 2,
            Sha384 = 3,
            Sha3_256 = 4,
            Sha3_512 = 5,
            Sha3_224 = 6,
            Sha3_384 = 7,
            Aes128 = 128,
            Aes192 = 129,
            Aes256 = 130,
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Algorithm {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    Algorithm::Sha256 => ::core::fmt::Formatter::write_str(f, "Sha256"),
                    Algorithm::Sha512 => ::core::fmt::Formatter::write_str(f, "Sha512"),
                    Algorithm::Sha224 => ::core::fmt::Formatter::write_str(f, "Sha224"),
                    Algorithm::Sha384 => ::core::fmt::Formatter::write_str(f, "Sha384"),
                    Algorithm::Sha3_256 => {
                        ::core::fmt::Formatter::write_str(f, "Sha3_256")
                    }
                    Algorithm::Sha3_512 => {
                        ::core::fmt::Formatter::write_str(f, "Sha3_512")
                    }
                    Algorithm::Sha3_224 => {
                        ::core::fmt::Formatter::write_str(f, "Sha3_224")
                    }
                    Algorithm::Sha3_384 => {
                        ::core::fmt::Formatter::write_str(f, "Sha3_384")
                    }
                    Algorithm::Aes128 => ::core::fmt::Formatter::write_str(f, "Aes128"),
                    Algorithm::Aes192 => ::core::fmt::Formatter::write_str(f, "Aes192"),
                    Algorithm::Aes256 => ::core::fmt::Formatter::write_str(f, "Aes256"),
                }
            }
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Algorithm {
            #[inline]
            fn clone(&self) -> Algorithm {
                *self
            }
        }
        #[automatically_derived]
        impl ::core::marker::Copy for Algorithm {}
        #[automatically_derived]
        impl ::core::marker::StructuralPartialEq for Algorithm {}
        #[automatically_derived]
        impl ::core::cmp::PartialEq for Algorithm {
            #[inline]
            fn eq(&self, other: &Algorithm) -> bool {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                let __arg1_tag = ::core::intrinsics::discriminant_value(other);
                __self_tag == __arg1_tag
            }
        }
        #[automatically_derived]
        impl ::core::marker::StructuralEq for Algorithm {}
        #[automatically_derived]
        impl ::core::cmp::Eq for Algorithm {
            #[inline]
            #[doc(hidden)]
            #[no_coverage]
            fn assert_receiver_is_total_eq(&self) -> () {}
        }
        #[automatically_derived]
        impl ::core::hash::Hash for Algorithm {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                let __self_tag = ::core::intrinsics::discriminant_value(self);
                ::core::hash::Hash::hash(&__self_tag, state)
            }
        }
        impl serde::Serialize for Algorithm {
            #[allow(clippy::use_self)]
            fn serialize<S>(
                &self,
                serializer: S,
            ) -> core::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                let value: u8 = match *self {
                    Algorithm::Sha256 => Algorithm::Sha256 as u8,
                    Algorithm::Sha512 => Algorithm::Sha512 as u8,
                    Algorithm::Sha224 => Algorithm::Sha224 as u8,
                    Algorithm::Sha384 => Algorithm::Sha384 as u8,
                    Algorithm::Sha3_256 => Algorithm::Sha3_256 as u8,
                    Algorithm::Sha3_512 => Algorithm::Sha3_512 as u8,
                    Algorithm::Sha3_224 => Algorithm::Sha3_224 as u8,
                    Algorithm::Sha3_384 => Algorithm::Sha3_384 as u8,
                    Algorithm::Aes128 => Algorithm::Aes128 as u8,
                    Algorithm::Aes192 => Algorithm::Aes192 as u8,
                    Algorithm::Aes256 => Algorithm::Aes256 as u8,
                };
                serde::Serialize::serialize(&value, serializer)
            }
        }
        impl<'de> serde::Deserialize<'de> for Algorithm {
            #[allow(clippy::use_self)]
            fn deserialize<D>(deserializer: D) -> core::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct discriminant;
                #[allow(non_upper_case_globals)]
                impl discriminant {
                    const Sha256: u8 = Algorithm::Sha256 as u8;
                    const Sha512: u8 = Algorithm::Sha512 as u8;
                    const Sha224: u8 = Algorithm::Sha224 as u8;
                    const Sha384: u8 = Algorithm::Sha384 as u8;
                    const Sha3_256: u8 = Algorithm::Sha3_256 as u8;
                    const Sha3_512: u8 = Algorithm::Sha3_512 as u8;
                    const Sha3_224: u8 = Algorithm::Sha3_224 as u8;
                    const Sha3_384: u8 = Algorithm::Sha3_384 as u8;
                    const Aes128: u8 = Algorithm::Aes128 as u8;
                    const Aes192: u8 = Algorithm::Aes192 as u8;
                    const Aes256: u8 = Algorithm::Aes256 as u8;
                }
                match <u8 as serde::Deserialize>::deserialize(deserializer)? {
                    discriminant::Sha256 => core::result::Result::Ok(Algorithm::Sha256),
                    discriminant::Sha512 => core::result::Result::Ok(Algorithm::Sha512),
                    discriminant::Sha224 => core::result::Result::Ok(Algorithm::Sha224),
                    discriminant::Sha384 => core::result::Result::Ok(Algorithm::Sha384),
                    discriminant::Sha3_256 => {
                        core::result::Result::Ok(Algorithm::Sha3_256)
                    }
                    discriminant::Sha3_512 => {
                        core::result::Result::Ok(Algorithm::Sha3_512)
                    }
                    discriminant::Sha3_224 => {
                        core::result::Result::Ok(Algorithm::Sha3_224)
                    }
                    discriminant::Sha3_384 => {
                        core::result::Result::Ok(Algorithm::Sha3_384)
                    }
                    discriminant::Aes128 => core::result::Result::Ok(Algorithm::Aes128),
                    discriminant::Aes192 => core::result::Result::Ok(Algorithm::Aes192),
                    discriminant::Aes256 => core::result::Result::Ok(Algorithm::Aes256),
                    other => {
                        core::result::Result::Err(
                            serde::de::Error::custom(
                                ::core::fmt::Arguments::new_v1(
                                    &[
                                        "invalid value: ",
                                        ", expected one of: ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                        ", ",
                                    ],
                                    &[
                                        ::core::fmt::ArgumentV1::new_display(&other),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Sha256),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Sha512),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Sha224),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Sha384),
                                        ::core::fmt::ArgumentV1::new_display(
                                            &discriminant::Sha3_256,
                                        ),
                                        ::core::fmt::ArgumentV1::new_display(
                                            &discriminant::Sha3_512,
                                        ),
                                        ::core::fmt::ArgumentV1::new_display(
                                            &discriminant::Sha3_224,
                                        ),
                                        ::core::fmt::ArgumentV1::new_display(
                                            &discriminant::Sha3_384,
                                        ),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Aes128),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Aes192),
                                        ::core::fmt::ArgumentV1::new_display(&discriminant::Aes256),
                                    ],
                                ),
                            ),
                        )
                    }
                }
            }
        }
    }
    mod context {
        use super::Tag;
        use crate::error::MacError;
        use cfg_if::cfg_if;
        use cmac::Cmac;
        use enum_dispatch::enum_dispatch;
        use hmac::{Hmac, Mac};
        use paste::paste;
        use ring_compat::ring::hmac::{HMAC_SHA256, HMAC_SHA384, HMAC_SHA512};
        use sha2::{Sha256, Sha384, Sha512};
        use aes::{Aes128, Aes192, Aes256};
        use sha2::Sha224;
        use sha3::{Sha3_224, Sha3_256, Sha3_384, Sha3_512};
        pub struct Context(ContextInner);
        enum ContextInner {
            #[cfg(feature = "ring")]
            RingContext(RingContext),
            RustCryptoContext(RustCryptoContext),
        }
        trait MacContext {
            fn update(&mut self, data: &[u8]);
            fn finalize(self) -> Tag;
        }
        #[cfg(feature = "ring")]
        impl ::core::convert::From<RingContext> for ContextInner {
            fn from(v: RingContext) -> ContextInner {
                ContextInner::RingContext(v)
            }
        }
        impl ::core::convert::From<RustCryptoContext> for ContextInner {
            fn from(v: RustCryptoContext) -> ContextInner {
                ContextInner::RustCryptoContext(v)
            }
        }
        #[cfg(feature = "ring")]
        impl core::convert::TryInto<RingContext> for ContextInner {
            type Error = &'static str;
            fn try_into(
                self,
            ) -> ::core::result::Result<
                RingContext,
                <Self as core::convert::TryInto<RingContext>>::Error,
            > {
                match self {
                    ContextInner::RingContext(v) => Ok(v),
                    ContextInner::RustCryptoContext(v) => {
                        Err("Tried to convert variant RustCryptoContext to RingContext")
                    }
                }
            }
        }
        impl core::convert::TryInto<RustCryptoContext> for ContextInner {
            type Error = &'static str;
            fn try_into(
                self,
            ) -> ::core::result::Result<
                RustCryptoContext,
                <Self as core::convert::TryInto<RustCryptoContext>>::Error,
            > {
                match self {
                    ContextInner::RustCryptoContext(v) => Ok(v),
                    #[cfg(feature = "ring")]
                    ContextInner::RingContext(v) => {
                        Err("Tried to convert variant RingContext to RustCryptoContext")
                    }
                }
            }
        }
        impl MacContext for ContextInner {
            #[inline]
            fn update(&mut self, __enum_dispatch_arg_0: &[u8]) {
                match self {
                    #[cfg(feature = "ring")]
                    ContextInner::RingContext(inner) => {
                        MacContext::update(inner, __enum_dispatch_arg_0)
                    }
                    ContextInner::RustCryptoContext(inner) => {
                        MacContext::update(inner, __enum_dispatch_arg_0)
                    }
                }
            }
            #[inline]
            fn finalize(self) -> Tag {
                match self {
                    #[cfg(feature = "ring")]
                    ContextInner::RingContext(inner) => MacContext::finalize(inner),
                    ContextInner::RustCryptoContext(inner) => MacContext::finalize(inner),
                }
            }
        }
        #[cfg(feature = "ring")]
        struct RingContext {}
        impl MacContext for RingContext {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not implemented")
            }
        }
        impl MacContext for RustCryptoContext {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not implemented")
            }
        }
        enum RustCryptoContext {}
        struct HmacSha224Context(Hmac<Sha224>);
        #[automatically_derived]
        impl ::core::clone::Clone for HmacSha224Context {
            #[inline]
            fn clone(&self) -> HmacSha224Context {
                HmacSha224Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HmacSha224Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HmacSha224Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for HmacSha224Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not yet implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not yet implemented")
            }
        }
        struct HmacSha3_224Context(Hmac<Sha3_224>);
        #[automatically_derived]
        impl ::core::clone::Clone for HmacSha3_224Context {
            #[inline]
            fn clone(&self) -> HmacSha3_224Context {
                HmacSha3_224Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HmacSha3_224Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HmacSha3_224Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for HmacSha3_224Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not yet implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not yet implemented")
            }
        }
        struct HmacSha3_256Context(Hmac<Sha3_256>);
        #[automatically_derived]
        impl ::core::clone::Clone for HmacSha3_256Context {
            #[inline]
            fn clone(&self) -> HmacSha3_256Context {
                HmacSha3_256Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HmacSha3_256Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HmacSha3_256Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for HmacSha3_256Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not yet implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not yet implemented")
            }
        }
        struct HmacSha3_384Context(Hmac<Sha3_384>);
        #[automatically_derived]
        impl ::core::clone::Clone for HmacSha3_384Context {
            #[inline]
            fn clone(&self) -> HmacSha3_384Context {
                HmacSha3_384Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HmacSha3_384Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HmacSha3_384Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for HmacSha3_384Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not yet implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not yet implemented")
            }
        }
        struct HmacSha3_512Context(Hmac<Sha3_512>);
        #[automatically_derived]
        impl ::core::clone::Clone for HmacSha3_512Context {
            #[inline]
            fn clone(&self) -> HmacSha3_512Context {
                HmacSha3_512Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for HmacSha3_512Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "HmacSha3_512Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for HmacSha3_512Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not yet implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not yet implemented")
            }
        }
        struct CmacAes128Context(Cmac<Aes128>);
        #[automatically_derived]
        impl ::core::clone::Clone for CmacAes128Context {
            #[inline]
            fn clone(&self) -> CmacAes128Context {
                CmacAes128Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CmacAes128Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CmacAes128Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for CmacAes128Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not implemented")
            }
        }
        struct CmacAes192Context(Cmac<Aes192>);
        #[automatically_derived]
        impl ::core::clone::Clone for CmacAes192Context {
            #[inline]
            fn clone(&self) -> CmacAes192Context {
                CmacAes192Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CmacAes192Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CmacAes192Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for CmacAes192Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not implemented")
            }
        }
        struct CmacAes256Context(Cmac<Aes256>);
        #[automatically_derived]
        impl ::core::clone::Clone for CmacAes256Context {
            #[inline]
            fn clone(&self) -> CmacAes256Context {
                CmacAes256Context(::core::clone::Clone::clone(&self.0))
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for CmacAes256Context {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_tuple_field1_finish(
                    f,
                    "CmacAes256Context",
                    &&self.0,
                )
            }
        }
        impl MacContext for CmacAes256Context {
            fn update(&mut self, data: &[u8]) {
                ::core::panicking::panic("not implemented")
            }
            fn finalize(self) -> Tag {
                ::core::panicking::panic("not implemented")
            }
        }
        enum RustCryptoContextInner {
            HmacSha224(HmacSha224Context),
            HmacSha3_224(HmacSha3_224Context),
            HmacSha3_256(HmacSha3_256Context),
            HmacSha3_384(HmacSha3_384Context),
            HmacSha3_512(HmacSha3_512Context),
            CmacAes128(CmacAes128Context),
            CmacAes192(CmacAes192Context),
            CmacAes256(CmacAes256Context),
        }
        #[automatically_derived]
        impl ::core::clone::Clone for RustCryptoContextInner {
            #[inline]
            fn clone(&self) -> RustCryptoContextInner {
                match self {
                    RustCryptoContextInner::HmacSha224(__self_0) => {
                        RustCryptoContextInner::HmacSha224(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::HmacSha3_224(__self_0) => {
                        RustCryptoContextInner::HmacSha3_224(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::HmacSha3_256(__self_0) => {
                        RustCryptoContextInner::HmacSha3_256(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::HmacSha3_384(__self_0) => {
                        RustCryptoContextInner::HmacSha3_384(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::HmacSha3_512(__self_0) => {
                        RustCryptoContextInner::HmacSha3_512(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::CmacAes128(__self_0) => {
                        RustCryptoContextInner::CmacAes128(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::CmacAes192(__self_0) => {
                        RustCryptoContextInner::CmacAes192(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                    RustCryptoContextInner::CmacAes256(__self_0) => {
                        RustCryptoContextInner::CmacAes256(
                            ::core::clone::Clone::clone(__self_0),
                        )
                    }
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for RustCryptoContextInner {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match self {
                    RustCryptoContextInner::HmacSha224(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "HmacSha224",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::HmacSha3_224(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "HmacSha3_224",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::HmacSha3_256(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "HmacSha3_256",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::HmacSha3_384(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "HmacSha3_384",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::HmacSha3_512(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "HmacSha3_512",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::CmacAes128(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CmacAes128",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::CmacAes192(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CmacAes192",
                            &__self_0,
                        )
                    }
                    RustCryptoContextInner::CmacAes256(__self_0) => {
                        ::core::fmt::Formatter::debug_tuple_field1_finish(
                            f,
                            "CmacAes256",
                            &__self_0,
                        )
                    }
                }
            }
        }
        impl MacContext for RustCryptoContextInner {
            fn update(&mut self, data: &[u8]) {
                match self {
                    Self::HmacSha224(ctx) => ctx.update(data),
                    Self::HmacSha3_224(ctx) => ctx.update(data),
                    Self::HmacSha3_256(ctx) => ctx.update(data),
                    Self::HmacSha3_384(ctx) => ctx.update(data),
                    Self::HmacSha3_512(ctx) => ctx.update(data),
                    Self::CmacAes128(ctx) => ctx.update(data),
                    Self::CmacAes192(ctx) => ctx.update(data),
                    Self::CmacAes256(ctx) => ctx.update(data),
                }
            }
            fn finalize(self) -> Tag {
                match self {
                    Self::HmacSha224(ctx) => ctx.finalize(),
                    Self::HmacSha3_224(ctx) => ctx.finalize(),
                    Self::HmacSha3_256(ctx) => ctx.finalize(),
                    Self::HmacSha3_384(ctx) => ctx.finalize(),
                    Self::HmacSha3_512(ctx) => ctx.finalize(),
                    Self::CmacAes128(ctx) => ctx.finalize(),
                    Self::CmacAes192(ctx) => ctx.finalize(),
                    Self::CmacAes256(ctx) => ctx.finalize(),
                }
            }
        }
    }
    mod key {
        use aes::{Aes128, Aes192, Aes256};
        use cmac::Cmac;
        use enum_dispatch::enum_dispatch;
        use hmac::{Hmac, Mac};
        use paste::paste;
        use sha2::{Sha224, Sha256, Sha384, Sha512};
        use sha3::{Sha3_224, Sha3_256, Sha3_384, Sha3_512};
        pub(super) trait MacKey {}
        enum KeyInner {}
        pub(super) struct HmacSha224(Hmac<Sha224>);
        pub(super) struct HmacSha256(Hmac<Sha256>);
        pub(super) struct HmacSha384(Hmac<Sha384>);
        pub(super) struct HmacSha512(Hmac<Sha512>);
        pub(super) struct HmacSha3_224(Hmac<Sha3_224>);
        pub(super) struct HmacSha3_256(Hmac<Sha3_256>);
        pub(super) struct HmacSha3_384(Hmac<Sha3_384>);
        pub(super) struct HmacSha3_512(Hmac<Sha3_512>);
        pub(super) struct CmacAes128(Cmac<Aes128>);
        pub(super) struct CmacAes192(Cmac<Aes192>);
        pub(super) struct CmacAes256(Cmac<Aes256>);
    }
    mod ring {}
    mod tag {
        pub struct Tag {
            bytes: Vec<u8>,
            len: usize,
        }
        #[automatically_derived]
        impl ::core::clone::Clone for Tag {
            #[inline]
            fn clone(&self) -> Tag {
                Tag {
                    bytes: ::core::clone::Clone::clone(&self.bytes),
                    len: ::core::clone::Clone::clone(&self.len),
                }
            }
        }
        #[automatically_derived]
        impl ::core::fmt::Debug for Tag {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                ::core::fmt::Formatter::debug_struct_field2_finish(
                    f,
                    "Tag",
                    "bytes",
                    &&self.bytes,
                    "len",
                    &&self.len,
                )
            }
        }
        impl PartialEq for Tag {
            fn eq(&self, other: &Self) -> bool {
                self.bytes[..self.len] == other.bytes[..other.len]
            }
        }
    }
    pub use tag::Tag;
    pub use algorithm::Algorithm;
}
pub mod constant_time {
    use crate::error::UnspecifiedError;
    #[cfg(feature = "ring")]
    pub fn verify_slices_are_equal(a: &[u8], b: &[u8]) -> Result<(), UnspecifiedError> {
        match ring_compat::ring::constant_time::verify_slices_are_equal(a, b) {
            Ok(()) => Ok(()),
            Err(_) => Err(UnspecifiedError),
        }
    }
}
pub mod hash {
    use serde::{Deserialize, Serialize};
    use crate::error::InvalidAlgorithm;
    #[serde(try_from = "u8", into = "u8")]
    pub enum Algorithm {
        Sha256 = 0,
        Sha384 = 1,
        Sha512 = 2,
        Blake3 = 3,
    }
    #[automatically_derived]
    impl ::core::clone::Clone for Algorithm {
        #[inline]
        fn clone(&self) -> Algorithm {
            *self
        }
    }
    #[automatically_derived]
    impl ::core::marker::Copy for Algorithm {}
    #[automatically_derived]
    impl ::core::fmt::Debug for Algorithm {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match self {
                Algorithm::Sha256 => ::core::fmt::Formatter::write_str(f, "Sha256"),
                Algorithm::Sha384 => ::core::fmt::Formatter::write_str(f, "Sha384"),
                Algorithm::Sha512 => ::core::fmt::Formatter::write_str(f, "Sha512"),
                Algorithm::Blake3 => ::core::fmt::Formatter::write_str(f, "Blake3"),
            }
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralPartialEq for Algorithm {}
    #[automatically_derived]
    impl ::core::cmp::PartialEq for Algorithm {
        #[inline]
        fn eq(&self, other: &Algorithm) -> bool {
            let __self_tag = ::core::intrinsics::discriminant_value(self);
            let __arg1_tag = ::core::intrinsics::discriminant_value(other);
            __self_tag == __arg1_tag
        }
    }
    #[automatically_derived]
    impl ::core::marker::StructuralEq for Algorithm {}
    #[automatically_derived]
    impl ::core::cmp::Eq for Algorithm {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {}
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Algorithm {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                _serde::Serialize::serialize(
                    &_serde::__private::Into::<
                        u8,
                    >::into(_serde::__private::Clone::clone(self)),
                    __serializer,
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(unused_extern_crates, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Algorithm {
            fn deserialize<__D>(
                __deserializer: __D,
            ) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                _serde::__private::Result::and_then(
                    <u8 as _serde::Deserialize>::deserialize(__deserializer),
                    |v| {
                        _serde::__private::TryFrom::try_from(v)
                            .map_err(_serde::de::Error::custom)
                    },
                )
            }
        }
    };
    impl From<Algorithm> for u8 {
        fn from(algorithm: Algorithm) -> Self {
            match algorithm {
                Algorithm::Sha256 => 0,
                Algorithm::Sha384 => 1,
                Algorithm::Sha512 => 2,
                Algorithm::Blake3 => 3,
            }
        }
    }
    impl TryFrom<u8> for Algorithm {
        type Error = InvalidAlgorithm;
        fn try_from(value: u8) -> Result<Self, Self::Error> {
            match value {
                0 => Ok(Algorithm::Sha256),
                1 => Ok(Algorithm::Sha384),
                2 => Ok(Algorithm::Sha512),
                _ => Err(InvalidAlgorithm(value)),
            }
        }
    }
}
pub mod aes {
    pub enum Aes {
        Aes128,
        Aes192,
        Aes256,
    }
}
